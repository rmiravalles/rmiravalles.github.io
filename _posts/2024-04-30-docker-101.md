---
layout: post
title: "Starting with Docker"
---
# The building blocks of the modern world

We all heard about containers, and we probably know they are everywhere. I like how the tech industry took the idea of the container.
I read somewhere that the standard shipping container may be considered one of the most important inventions of the modern world.
It allowed for the easier transportation of goods across the oceans, roads and railways. The same happens to the containers we are more familiar with.

I wanted to dedicate my first article in this blog to containers, and my first experiments with it. If we're going to explore Kubernetes,
we need to know something about Docker first. I wanted it to be short and hands-on too.

# An overview of containers

In the physical server world, your applications run on a dedicated machine, with its dedicated operating system and all the underlying hardware.
Server virtualization can be broadly characterized as a way to share the resources of a single physical server among multiple running operating
systems. Each virtual machine is independent and have its own lifecycle.

Container virtualization lightens the load even more.

# Installing Docker

I'm running [Xubuntu](https://xubuntu.org/) 22.04 in my old and puny Lenovo laptop. As a quick side note, if you have an old laptop
gathering dust in some corner of your house, you might consider installing Xubuntu in it. It's lightweight, it's stable and
I really dig the Xfce desktop environment.

Being said that, the easiest and fastest way to install the Docker engine in a Linux machine is using Snap. This is the command:

`sudo snap install docker`

[Docker Desktop](https://docs.docker.com/desktop/install/linux-install/) is available for Linux, but I wouldn't dare install it
in this machine. Docker Desktop consumes a lot of resources. It has the advantage, though, of the built-in Kubernetes. 

# Images and containers

Docker images are read-only templates used to build containers. They come packaged with the application code, and everything else the application needs to run. The **Dockerfile** is a file with a set of instructions that tell Doker how to build the container. Once you have your Dockerfile readym you run `docker build` to actually build the image into a container.

# Building a container

For this experiment, I grabbed a super simple [NGINX](https://www.nginx.com/) webserver that I took from their [GitHub repository](https://github.com/nginxinc/NGINX-Demos/tree/master/nginx-hello). I tweaked it a little bit, and create 2 different versions. I used these 2 versions for my other experiments with AKS, which I'll share in a while. Here's how they look like.

![Version 1 of The APP](../assets/images/theappv1.png)

![Version 1 of The APP](../assets/images/theappv2.png)

## Cloning the GitHub repository

I'm hosting the 2 versions of this app in [my GitHub repository](https://github.com/rmiravalles/theapp). Feel free to grab it for your own experiments.

To clone this repository, this is the command you run.

`git clone https://github.com/rmiravalles/theapp`

You'll notice that this repository has 2 branches, **v1** and **v2**. You can see all the branches in the repository by running `git branch -a`.

![branches](../assets/images/gitbranch.png)

To switch between branches, you run `git checkout [<branch>]`. Let's move to the branch **v1**.

![git checkout](../assets/images/gitcheckoutv1.png)

There's a Dockerfile already in there, so this is ready to be built. This is what it looks like.

```
FROM nginx:mainline-alpine
RUN rm /etc/nginx/conf.d/*
ADD hello.conf /etc/nginx/conf.d/
ADD index.html /usr/share/nginx/html/
EXPOSE 80
```
This file will tell Docker to use the **mainline-alpine** image from Docker Hub, remove whatever content is inside the `/etc/nginx/conf.d/` directory and add the `hello.conf` to it. It then tells Docker to add the `index.html` to the `/usr/share/nginx/html/`. Finally, we expose it on port 80. Let's build this container!

`sudo docker build -t theapp:v1 .`

The command above needs to be executed from the folder where all these files live. The `-t` flag is the tag, and the `.` tells Docker to go through the current directory.

To see the container in action, this is the command.

`docker run -d -p 8081:80 theapp:v1`

And this is our container up and running!

![exposed app](../assets/images/exposedv1local.png)





